#--------------------------------------------------------------------#
# Алгоритм Дейкстры                                 #
#--------------------------------------------------------------------#

# Создание матрицы смежности
import math

def get_link_v(v, D):
    for i, weight in enumerate(D[v]):
        if weight > 0:
            yield  i

def arg_min(T, S):
    amin = -1                          # Если просмотрели все вершины
    m = max(T)                         # Максимальное занчение в Т (для упрощения
    for i, t in enumerate(T):
        if t < m and i not in S:       # Минималоьное значение для вершин которые не рассмотрели
            m = t
            amin = i

    return amin




D = ((0, 3, 1, 3, 0, 0),
    (3, 0, 4, 0, 0, 0),
    (1, 4, 0, 0, 7, 5),
    (3, 0, 0, 0, 0, 2),
    (0, 0, 7, 0, 0, 4),
    (0, 0, 5, 2, 4, 0))


N = len(D)                          # Число вершин в графе
T = [math.inf] * N                  # СПоследняя строка таблицы


v = 0                               # Стартова вершина (нумерация с нуля)
S = {v}                             # Просмнтренные вершины
T[v] = 0                            # Нулевой вес для стартовой вершины

while v != -1:                      # Цыкл пока не просмотрим все вершины
    for j in get_link_v(v, D):      # Перебор всех связанных вершин с вершиной v
        if j not in S:              # Если вершина еще не просмотрена
            w = T[v] + D[v][j]
            if w < T[j]:
                T[j] = w

    v = arg_min(T, S)              # Выбераем следующий узел с наименьшим весом
    if v > 0:                      # Выбрана очередная вершина
        S.add(v)                   # Добавляем новую вершину в рассмотрение

print(T)

#--------------------------------------------------------------------#
# Алгоритм Флойда                                 #
#--------------------------------------------------------------------#

